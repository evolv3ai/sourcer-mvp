# Story 5.2: Enable Text Query Input and Submission

## Status: Approved

## Story

-   As an AI Enthusiast,
-   I want to be able to type my query into a text field as an alternative to voice,
-   so that I can use the application if voice input is problematic or not preferred.

## Acceptance Criteria (ACs)

1.  A functional `QLineEdit` widget (the `TextInputField`) is present and visible within the `InputControlWidget` area of the main window.
2.  Users can type and edit text (e.g., using backspace, delete, arrow keys) within the `TextInputField`.
3.  The `TextInputField` displays placeholder text (e.g., "Type your query here...") when empty and not focused, as per UI/UX specs.
4.  A `QPushButton` (the `Send/ActivateButton`) is present and visible next to or near the `TextInputField` in the `InputControlWidget`.
5.  Pressing the 'Enter' key while the `TextInputField` has focus submits the current text content as a query to the `CoreOrchestrator` (e.g., via `CoreOrchestrator.process_text_query(text)`).
6.  Clicking the `Send/ActivateButton` submits the current text content from the `TextInputField` as a query to the `CoreOrchestrator`.
7.  The `Send/ActivateButton` is enabled only when the `TextInputField` contains non-whitespace text; it is disabled if the `TextInputField` is empty.
8.  After a query is successfully submitted (by either Enter key or Send button), the `TextInputField` is cleared of its content.
9.  The typed query is subsequently displayed in the `ChatLogWidget` (handled by logic from Story 4.2, triggered by `CoreOrchestrator`).
10. The `Send/ActivateButton` has an appropriate tooltip (e.g., "Send Text Query").

## Tasks / Subtasks

-   [ ] **Task 1: Implement `TextInputField` Functionality (AC: 1, 2, 3, 7)**
    -   [ ] In `src/sourcer/ui/main_window.py` or a dedicated `src/sourcer/ui/widgets/input_control_widget.py` (if refactored into its own class):
        -   [ ] Ensure the `QLineEdit` instance for `TextInputField` (created as a stub in Story 1.1) is fully functional.
        -   [ ] Set its placeholder text (e.g., `self.text_input.setPlaceholderText("Type your query here...")`).
        -   [ ] Connect its `textChanged` signal to a handler method that enables/disables the `Send/ActivateButton` based on whether the field contains non-whitespace text.
-   [ ] **Task 2: Implement `Send/ActivateButton` Functionality (AC: 4, 7, 10)**
    -   [ ] Ensure the `QPushButton` instance for `Send/ActivateButton` (created as a stub in Story 1.1) is functional.
    -   [ ] Style it with text (e.g., "Send") or an icon as per UI/UX Specification.
    -   [ ] Set its tooltip (e.g., `self.send_button.setToolTip("Send Text Query")`).
    -   [ ] Initialize its state to disabled if `TextInputField` is initially empty.
-   [ ] **Task 3: Connect Text Input Submission to `CoreOrchestrator` (AC: 5, 6, 8)**
    -   [ ] Create a handler method in the UI layer (e.g., `submit_text_query()`). This method should:
        -   [ ] Get the current text from `TextInputField`.
        -   [ ] If the text is not empty, call the appropriate method on the `CoreOrchestrator` instance (e.g., `self.core_orchestrator.process_text_query(text_from_field)`).
        -   [ ] Clear the `TextInputField` (`self.text_input.clear()`).
        -   [ ] (Optionally) Return focus to the `TextInputField`.
    -   [ ] Connect the `Send/ActivateButton.clicked` signal to this `submit_text_query()` handler.
    -   [ ] Connect the `TextInputField.returnPressed` signal (for Enter key) to this `submit_text_query()` handler.
-   [ ] **Task 4: Verify Integration with `CoreOrchestrator` and `ChatLogWidget` (AC: 9)**
    -   [ ] Ensure the `CoreOrchestrator` (modified in Story 2.1 or as needed) has a method like `process_text_query(text: str)` that:
        -   Logs the received text query.
        -   Emits the `newQueryDisplayed` signal (from Story 4.2) so the `ChatLogWidget` displays the typed query.
        -   (In subsequent stories) Triggers the vision analysis pipeline using this text query.
    -   [ ] Manually test that submitting a text query results in the query appearing in the `ChatLogWidget`.

## Dev Technical Guidance

-   **UI Elements:**
    -   `TextInputField`: Use `QLineEdit`. Key signals: `textChanged`, `returnPressed`. Methods: `text()`, `clear()`, `setPlaceholderText()`.
    -   `Send/ActivateButton`: Use `QPushButton`. Key signal: `clicked`. Methods: `setEnabled(bool)`, `setToolTip()`.
-   **State Management:** The enabled/disabled state of the `Send/ActivateButton` depends on the content of `TextInputField`. This is typically managed within the UI code by connecting the `textChanged` signal of the `QLineEdit` to a slot that updates the button's state.
-   **`CoreOrchestrator` Interaction:** The UI should call a method on the `CoreOrchestrator` instance to submit the query text. The `CoreOrchestrator` is then responsible for further processing (logging the query, displaying it via `ChatLogWidget` signal, and eventually sending it to the vision pipeline).
-   **Focus Management:** Consider returning focus to the `TextInputField` after submission for a smoother experience if the user wants to type multiple queries, as noted in the UI/UX spec.
-   **Re-using Existing Logic:** This story leverages the `CoreOrchestrator`'s capability (developed in Story 2.1 and 4.2) to signal the `ChatLogWidget` to display user queries. The main new work is wiring up the text input elements and their specific submission logic.

## Story Progress Notes

### Agent Model Used: `<Agent Model Name/Version>`

### Completion Notes List
{Any notes about implementation choices, difficulties, or follow-up needed}

### Change Log