# Story 4.2: Display Query and Textual Description in Chat/Log

## Status: Approved

## Story

-   As an AI Enthusiast,
-   I want to see the textual description [from the visual analysis] in the chat/log area along with my query,
-   so that I have a record of the interaction.

## Acceptance Criteria (ACs)

1.  When the `CoreOrchestrator` processes a user query (transcribed voice from Story 2.1 or typed text), the original user query text is displayed as an entry in the `ChatLogWidget`.
2.  Following a visual analysis (Story 3.1), the textual description (`SceneDescription.full_text`) generated by the `VisionService` is displayed as a new entry in the `ChatLogWidget`, immediately following the corresponding user query.
3.  Entries in the `ChatLogWidget` maintain chronological order, forming a conversation history for the current session.
4.  The `ChatLogWidget` automatically scrolls to ensure the most recent entry (either query or response) is visible.
5.  User queries and system responses are visually distinguished within the `ChatLogWidget` (e.g., using prefixes like "You: ", "Sourcer: ", different text alignment, or subtle background differences as detailed in the UI/UX Specification).

## Tasks / Subtasks

-   [ ] **Task 1: Update `CoreOrchestrator` to Signal UI with Query and Response (AC: 1, 2)**
    -   [ ] In `src/sourcer/core/orchestrator.py`:
        -   [ ] When a user query (either transcribed voice or typed text) is finalized, define a Qt signal (e.g., `newQueryDisplayed = pyqtSignal(str)`) and emit it with the query text.
        -   [ ] After receiving the textual description from `VisionService.analyze_frame()`, define another Qt signal (e.g., `newResponseDisplayed = pyqtSignal(str)`) and emit it with the response text.
-   [ ] **Task 2: Implement `ChatLogWidget` Functionality (AC: 1, 2, 3, 4, 5)**
    -   [ ] Create/Update `src/sourcer/ui/widgets/chat_log_widget.py` (if not already a functional class, replace placeholder from Story 1.1).
    -   [ ] Define the `ChatLogWidget` class (e.g., inheriting from `QTextBrowser` or using a `QListWidget` with custom delegates if more complex styling is needed. `QTextBrowser` is simpler for rich text/HTML appending).
    -   [ ] Set the widget to be read-only.
    -   [ ] Implement a public method/slot (e.g., `add_user_message(text: str)`) that:
        -   Formats the user's query (e.g., prepends "You: ", applies styling for visual distinction as per UI/UX Spec).
        -   Appends the formatted query as a new paragraph/entry to the widget.
        -   Ensures auto-scrolling to the bottom.
    -   [ ] Implement a public method/slot (e.g., `add_sourcer_message(text: str)`) that:
        -   Formats the system's response (e.g., prepends "Sourcer: ", applies styling for visual distinction).
        -   Appends the formatted response as a new paragraph/entry to the widget.
        -   Ensures auto-scrolling to the bottom.
-   [ ] **Task 3: Integrate `ChatLogWidget` with `MainWindow` and `CoreOrchestrator` Signals (AC: 1, 2, 4)**
    -   [ ] In `src/sourcer/ui/main_window.py`:
        -   [ ] Instantiate the functional `ChatLogWidget` (replacing any placeholder from Story 1.1).
        -   [ ] Add it to the main window's layout in the designated area.
        -   [ ] Connect the `CoreOrchestrator.newQueryDisplayed` signal to `ChatLogWidget.add_user_message`.
        -   [ ] Connect the `CoreOrchestrator.newResponseDisplayed` signal to `ChatLogWidget.add_sourcer_message`.
-   [ ] **Task 4: Implement Visual Distinction for Messages (AC: 5)**
    -   [ ] Within `ChatLogWidget`'s message adding methods, apply basic HTML formatting (if using `QTextBrowser`) or specific item styling (if using `QListWidget`) to visually differentiate user queries from system responses.
    -   Refer to UI/UX Specification (`Sourcer-MVP-Wireframes-and-Mockups.txt`) for styling guidance (e.g., "User Message Bubbles/Entries: Background accent_color_light... Text: primary text color", "Sourcer Message Bubbles/Entries: Background secondary_background_chat...").

## Dev Technical Guidance

-   **Widget Choice:** `QTextBrowser` is suitable for displaying formatted text (HTML subset) and supports auto-scrolling. It can be made read-only. Methods like `append()` or `insertHtml()` would be used.
-   **Visual Styling:** Use simple HTML within `QTextBrowser.append()` for basic styling (e.g., `<b>You:</b> query<br>`, `<p style="color:blue;">Sourcer: response</p>`) or Qt StyleSheets applied to the `ChatLogWidget` or specific text formats. Refer to UI/UX mockups/descriptions for the desired "clean, functional, and modern minimalist" look.
-   **Signal/Slot Mechanism:** Ensure proper use of Qt signals and slots for communication from `CoreOrchestrator` (potentially running logic in a separate thread) to the `ChatLogWidget` (UI thread) to avoid threading issues.
-   **Auto-Scrolling:** `QTextBrowser` can be made to auto-scroll to the bottom by moving the cursor to the end after appending text (`text_browser.moveCursor(QTextCursor.MoveOperation.End)`).
-   **Session History:** The AC states "Chat history persists for the current session." This means the content of `ChatLogWidget` is not saved to disk between application runs for MVP.

## Story Progress Notes

### Agent Model Used: `<Agent Model Name/Version>`

### Completion Notes List
{Any notes about implementation choices, difficulties, or follow-up needed}

### Change Log